动态规划：分治法是将问题拆分为更小的子问题，而动态规划求解**所有**更小的子问题，但**只复用最优**子问题的解。

问题：**有向无环图（DAG）中的最短路径**
- “线性化”：可以将所有节点排成一条线，使得所有边都从左指向右。
- ![[dag.png]]
 在动态规划中，我们并不会显式给出一个有向无环图（DAG）；这个 DAG 是**隐含的（implicit）**。它的节点是我们定义的**子问题（状态）**，它的边则是子问题之间的**依赖关系（转移函数）**：
    - 如果要解决子问题 B 需要先知道子问题 A 的解，那么从 A 到 B 存在一条（概念上的）有向边。
    - 在这种情况下，A 被认为是比 B 更小的子问题。
解决动态规划问题：
- 确定**子问题**的集合。（状态）  
    – 这些子问题必须具有某种**最优子结构**性质。  
    – 较小的子问题应有助于解决较大的问题。
- 确定子问题之间的关系。（**递推关系**，转移函数）
- 计算最优解的值，通常采用**自底向上**的方式。
- 从已计算的信息中构造最优解。

问题：最长递增子序列
![[lis.png]]

weighted interval scheduling问题：
![[算法/wis.png]]方法1：![[wis2.png]]
![[wis3.png]]**观察**：递归算法会由于重复子问题而“惨败”，导致指数级时间复杂度的算法。
**优化** ：把每个子问题的结果存储在一个数组中 算法用时O(n log n)（包括用结束时间排序、用起始时间算p(n)，还有每次计算M[j]，实际在递归上用时O(n)）
- 带递归方法：![[wis4.png]]
- 不带递归方法：![[wis5.png]]
- 还想要动态规划的具体方案而不止最优结果：![[wis6.png]]

最长公共子串问题(LCS)：x[1,..,m] y[1,...,n]
朴素算法：对于x的每个子串，检查它是不是y的子串。最差时间：cita(n2^m)
![[LCS.png]]
![[LCS2.png]]![[LCS3.png]]
![[LCS4.png]]

背包问题：![[knap.png]]
![[knap2.png]]
带权重的最优二分查找树：希望找出最终cost最小的二分查找树![[BST.png]]
![[BST2.png]]

多个矩阵乘法：A(d×e)B(e×f)，时间为O(def)，多个矩阵可以用结合律来减少开销
![[matrix.png]]
![[matrix2.png]]![[matrix3.png]]

树上独立集：?
![[算法/treewis.png]]
![[treewis2.png]]

旅行商问题：返回能经过每一个点的最短路径（在带权无向图上）
朴素算法：O(n!)  当前最好的算法O(n^2*2^n)
对于旅行商问题（TSP），什么是合适的子问题？
- 子问题指的是**部分解**：旅行路径的初始部分。
- 假设我们从城市 **1** 出发，现在处于城市 **j**。
- 需要知道当前在城市 **j**（以决定下一个最方便访问的城市）。
- 需要知道目前为止已经访问过的所有城市，以避免重复访问。
![[TSP.png]]![[TSP2.png]]

区间动态规划问题：**问题**：给定一个字符串 x=x1...xnx = x_1...x_nx=x1​...xn​，求将其变为回文串所需插入的最少字符数。**示例**：xxx：`Ab3bd`可以通过插入两个字符（一个 ‘d’，一个 ‘A’）变成 “`dAb3bd`” 或 “`Adb3bdA`”
![[IDP.png]]