网络流的概念：建模“物质通过有限容量通道传输”的基本概念。例子：水流、电流、数据等，可以有**单源/单汇**、**多源/多汇**，或多商品（multi-commodity）情形
![[flownet.png]]![[flow.png]]
**流的抵消（Flow Cancellation）**： **不失一般性地**，正向流量只能**从 u 到 v**，或者**从 v 到 u**，但**不能同时存在**。
- 图示转换前：
    - 从 u→v：1/2
    - 从 v→u：2/3
- 图示转换后：
    - 从 u→v：1/3
    - 从 v→u：0/2
- 在两种情况下，从 u 到 v 的**净流量均为 1**。
- **这种变换不会破坏容量限制与流守恒约束**。

流分解： **任何可行流（feasible flow）** 在网络 G 上的一个可行流 f 可以被分解为**最多 m 条循环（cycles）和 s-t路径（path flow）**。
![[flowdecomposition.png]]

残差网络：cf(u,v) = c(u,v) – f(u,v) ≥ 0 ，残差网络Gf是残差严格大于0的部分组成的，它的边来自G∪G^T （Gf的反向边大小是通过c正+c反-cf表达的
![[residual.png]]
增广路径：![[augmentingpath.png]]
![[augmentingpath2.png]]
![[augmentingpath3.png]]

Ford-Fulkerson算法：
![[FordF.png]]
	潜在问题：
	🔴 **收敛性？是否可能进入无限循环？**  不会，因为我们只接受增广路径（augmenting paths）。
	🔴 **我们是否能保证在存在增广路径时一定能找到它？**  广度优先搜索（BFS）可以找到从源点出发的所有最短路径。如果没有任何路径能到达汇点（sink），则说明增广路径不存在。**其实我们真正想要的是“最大容量路径”。**
	🔴 **全局最优？** 当再也找不到增广路径时，我们怎么知道当前解是全局最优，而不是仅仅是一个局部最优解？
	**Ford-Fulkerson 算法**被保证每次执行都能产生**渐进式改进**。 当再也无法改进时，即找不到增广路径，说明**已找到最大流**。
	![[FordF2.png]]

流的性质：
![[flowpropertiy.png]]![[flowproperty2.png]]

割：![[cut.png]]
![[cut2.png]]
f(S, T) ≤ c(S, T) for all cuts (S, T)
最大流最小割定理：以下三者等价：
1. f 是图 G 中的一组**最大流**；
2. 残量网络 G_f中**不存在增广路径（augmenting paths）**；
3. 对于某个割 (S,T) 有 ∣f∣=c(S,T)   即该割的容量等于总流量。
	![[maxflowmincut.png]]
	所以 f(u,v)=c(u,v), since cf(u, v) = c(u,v) – f(u,v).  |f| = f(S, T) = c(S, T).

Edmonds-Karp算法：
- 修改 Dijkstra 算法以寻找**容量最大的增广路径**（即“最大瓶颈路径”）。
	🔴 **命题 1（Claim 1）：**  在最大 s→t流为 F 的图中，必定存在一条从 s 到 t 的路径，其容量至少为F/m（其中 m 是边的数量）
	🔴 **命题 2（Claim 2）：**  Edmonds-Karp 算法第一个版本最多进行
O(mlog⁡F)次迭代。
	🔴 **运行时间：** O(m^2log⁡nlog⁡F)
- **使用 BFS 寻找广度优先的增广路径**
	- 查找一条增广路径的时间为：Θ(V+E)；如果所有顶点都可以从源点到达，则简化为Θ(E)
	- **命题：**  增广的总次数被限制在Θ(VE)。 因此，总运行时间为：Θ(VE^2)
	- 单调性引理：![[edmond.png]]
	![[mono.png]]
	![[mono2.png]]
	- 证明：增广的总次数在Θ(VE)
		设 p 是某条增广路径。 路径中某条边 (u,v)的残余容量为cf(p)=cf(u,v)，此时称 (u,v)为**关键边（critical）**
		- 一次增广操作会使这条边 (u,v)(u, v)(u,v)**饱和**，暂时从残量图中移除
		- 直到反向边 (v,u)(v, u)(v,u) 被增广之后，该边才可能重新出现在图中
		在增广 (u,v)之前，有：D(v)=D(u)+1（因为是广度优先路径），之后当试图增广反向边 (v,u 时：D′(u)=D′(v)+1≥D(v)+1≥D(u)+2
		因此，结论是： D(u)每次在边 (u,v)被关键时会**至少增长 2** ,而每个节点 u 的广度优先距离最多从 0 增加到 ∣V∣−1，  所以边 (u,v)最多成为关键边 Θ(V)次，所有残量图中的边数为 Θ(E)，因此最多增广次数为：Θ(VE)
等级分层图：![[levelgraph.png]]
![[levelgraph2.png]]

**阻塞流（Blocking Flow）** 若图 G 中的某个流 f 满足：**任意一条从 s 到 t 的路径上至少有一条边是饱和的（即流量达到容量）**，则称该流为**阻塞流（blocking）**。
- **每个最大流（maximum flow）显然也是一个阻塞流。**
- 但反过来：**每个阻塞流是否都是最大流？**
    - ❌ **不是的（No）**
- ❓那么：**如何高效地找到一个阻塞流？**

dinic算法：
- 单轮阶段：
	🔴 **遍历分层图（level graph）**，从源点到汇点，以**深度优先方式（depth-first fashion）** 进行。
	🔴 每当可以向前推进（advance）时，就继续前进，并记录从源点 s 到当前顶点的路径。
	🔴 如果我们成功到达汇点 t，则找到了一个**增广路径**，随后**通过该路径执行增广操作（augment）**。
	🔴 如果当前顶点**没有任何出边**，我们就**删除该顶点**并**回退**
	![[dinic.png]]
	![[dinic2.png]]
	![[dinic3.png]]
- 分析：
	🔴 **定理 1：**  在**有向无环图**中，阻塞流（blocking flow）可以在
O(mn)时间内找到；若使用高级数据结构，则可以在O(mlog⁡n)时间内找到。
	🔴 **引理 2：**  每一轮算法中，**汇点 dt 的距离严格递增**。
	🔴 **定理 3：**  Dinic 算法可以被实现为：O(mn^2)时间复杂度（Dinic 1970），或O(mnlog⁡n)时间复杂度（Sleator & Tarjan 1980）
- 单位容量图：![[dinic4.png]]

应用1：边不相交路径问题
给定一个有向图 G=(V,E) 和两个节点 s 与 t，求从 s 到 t 的**最多条数的边不相交路径（edge-disjoint paths）**。若两条路径**没有任何公共边**，则称它们是**边不相交的（edge-disjoint）**。
定理：**最大流建模（Max flow formulation）：** 为图中**每条边赋予单位容量。从 s 到 t 的最多条数的**边不相交路径数** = **最大流的数值。**
	证明：![[edp.png]]
	![[edp2.png]]

应用2：**匹配（Matching）**
**输入：** 一个无向图 G=(V,E)，若 M⊆E且图中每个节点在 M 中最多只出现在一条边上，则称 M 为一个**匹配（matching）**。 **最大匹配（Max matching）：**  指的是找到**包含边数最多**的一个匹配，即最大基数匹配
**二分图匹配（Bipartite Matching）**  **输入：** 一个无向图 G=(L∪R,E)，其中 L、R 是左右两个点集。若 M⊆E，且每个节点在 M 中至多出现在一条边上，则称 M 为一个**匹配（matching）** ，寻找**边数最多**的一个匹配（最大基数匹配）
定理： **最大流建模（Max flow formulation）** 构造一个有向图 G′=(L∪R∪{s,t},E′)  ，将所有边从左侧集合 L 指向右侧集合 R，并赋予**无限容量**（或单位容量）；添加源点 s，并从 s 向每个 L 中的节点连接**单位容量的边** 添加汇点 t，并从每个 R 中的节点向 t 连接**单位容量的边**
	证明：![[BM.png]]
运行时长：![[BM2.png]]

应用3：图像分割
为图像中的每个像素打标签，判断其属于前景还是背景。V：像素集合，  
E：相邻像素对的集合。ai≥0：表示像素 i 属于前景的**概率/置信度**。bi≥0：表示像素 i 属于背景的**概率/置信度**。pij≥0：若将像素 i 和 j 分别标记为前景和背景，或反过来，所产生的**割裂惩罚**。前景的点集合为A，背景的点集合为B
![[IS 2.png]]
![[IS3.png]]
建模：将问题建模为**最小割问题**。构造图 G′=(V,E′)， 添加源点 s，表示“前景”；添加汇点 t，表示“背景”，将原始图中的无向边替换为**两个方向相反的有向边（反向边对）**
![[IS4.png]]![[IS5.png]]
![[IS6.png]]