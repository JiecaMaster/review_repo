数据结构：支持特定的操作（插入、删除、搜索），关注操作的效率
直接访问表：![[direct.png]]

哈希函数：把所有Key映射到{0,1,..,m-1}，若有冲突则用一个list或一个链表链接起来，代表处于同一个槽
简单均匀哈希（simple uniform hashing）的假设：对于每个键 k∈K，它被哈希到表 T 中任意槽位的可能性是相等的，且与其他键被哈希的位置无关。设 n 为表中键的数量，m 为槽位（slots）的数量。定义表 T 的**装载因子（load factor)** 为：α=n/m，即：**每个槽位上的平均键数。**
搜索效率：T(n)=cita(1+α)
选择哈希函数：
- **乘法法（Multiplication method）** ：假设所有键都是整数，m = 2^r，且我们的计算机使用 w 位字长。定义：h(k)=(A⋅k  mod 2^w) rsh (w−r)其中，rsh 是“按位右移”操作，  且 A 是满足 2^(w−1)<A<2^w的奇数。不要选择离2^w过近的A
- 点积法：![[dianji.png]]
- 基于表格的：![[tabulation.png]]
哈希的缺点：对于任意一个哈希函数 h，总存在某个键的集合，会导致哈希表的平均访问时间急剧上升。例如，一个攻击者可以选择所有满足{k∈U:h(k)=i}的键（即所有被映射到某个槽位 i的键）。
方法：随机选择哈希函数，该选择过程与键无关
全局哈希：![[算法/unihash.png]]
![[unihash2.png]]- 构造简单全局哈希：
![[unihash3.png]]
证明它是全局哈希：给定x,y，由于x≠y，不妨令x0≠y0，则![[unihash4.png]]由数论的一个知识（对于任意小于m的整数z，存在唯一的小于m的整数z^-1，使得z×z^-1=1 (mod m)，得知对于任意a1,..ar的选取，只有一个唯一的a0会导致x和y冲突。那么导致冲突的hash函数数为m^r=|H|/m

完美哈希：![[perhash.png]]
![[perhash2.png]]
![[perhash3.png]]推论：如果我们将 n 个键存储在一个大小为 m=n 的哈希表中，并使用从通用哈希函数类中随机选取的哈希函数 h，并将每个二级哈希表的大小设置为mj=nj^2，对于 j=0,1,…,m−1；那么，在完美哈希方案中，所有二级哈希表所需的**期望总存储量**小于 2n。

开放寻址法解决冲突：哈希表本身之外不使用额外的存储。插入操作会系统地探测表，直到找到一个空槽位为止。哈希函数依赖于键和探测次数。
- 线性插入：h(k,i) = (h'(k) + i) mod m. 哈希表越满，查找时间越多
- double哈希：h(k,i) = (h1(k) + i×h2(k)) mod m. 要求 h2(k) 与 m 互素。
一种可行的做法是将 m设为 2 的幂， 并设计 h2(k) 只产生奇数。
分析：
- 给定一个装载因子为α的开放寻址散列表，并假设是均匀散列的，则对于一次不成功的查找，其期望的探查次数至多为1/(1-α)
- 给定一个装载因子为α的开放寻址散列表，一次成功查找中的探查期望值最多是（1/α）*ln1/(1-α)

给定一个全集 U上的集合 S={x1,x2,x3,…,xn}，  我们希望回答如下形式的查询：y∈S吗？如，所有可能的 URL 字符串组成的全集中的一组 URL。Bloom 过滤器可以用于回答此类问题，具有以下特点：  
    – “常数”时间（哈希所需时间）；  
    – 占用较小的空间；  
    – 但有一定的错误概率。
![[bloom.png]]
![[bloom2.png]]应用：网页url的传播，m/n是bits/item，k是time，f是FP率

Count-Min Sketch：
![[sketch.png]]
![[sketch2.png]]
![[sketch3.png]]![[sketch4.png]]