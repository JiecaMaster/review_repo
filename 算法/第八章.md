图表达：G=(V,E),如果图是连通的，则E≥V-1
- 可以分为有向图和无向图
- 关联矩阵O(V^2)：i和j相连就有`A[i][j]=1`
- 关联列表cita(V+E)：对于每个顶点v，存一个列表`Adj[v]`来表示链接到v的其余顶点，如果是有向的则表达的都是起点在v的边
- 握手引理：对于无向图，所有顶点的度数和是边的两倍

生成树：连接所有顶点的树
最小生成树：加起来边权最小的生成树
最优结构：证明，w(T) = w(u,v) + w(T1) + w(T2)，不会有比T1和T2更好的生成树了，否则T不会是最小生成树![[MST.png]]
贪心算法：
	![[MSP2.png]]
	证明：![[MST3.png]]
**割规则（Cut Rule）**：对于图中的任意一个割（即将顶点划分为两个集合的方式），**跨越该割的最小权重边必须包含在最小生成树（MST）中**。该规则帮助我们判断哪些边应该加入到最小生成树中。
**环规则（Cycle Rule）**：如果图中存在一个环，那么**该环中权重最大的边不能出现在最小生成树中**。 该规则帮助我们判断在构造最小生成树时哪些边应被移除。
**Prim's算法：** 这里的Extreactmin指的是取Q中key最小的节点出来，并在Q中删掉该节点![[prims.png]]
![[prims2.png]]
**Kruskal算法** ：![[kruskal.png]]
![[kruskal2.png]]实现Kruskal算法的数据结构：
方法1：linked list
- 链表中的**第一个元素**作为该集合的代表（representative）
- 每个节点包含：
    - 一个元素（element）    
    - 指向链表中**下一个节点**的指针  
    - 指向该集合**代表元素**的指针
    ![[linkedlist.png]]
	![[linkedlist2.png]]
	union的优化方法：直接把B插入到x之后，相当于插在A中间，总是**将较短的链表拼接到较长的链表中** ，时间复杂度为O(min⁡{LA,LB})
	定理：对任意一系列 m 次操作，其总时间复杂度为O(m+nlog⁡n)：使用**摊还分析（Amortized Analysis）**。
方法2：up-tree
	![[uptree.png]]
	![[uptree2.png]]
	union: 直接把一个的根指向另一个的根。时间为O(1)，但最坏情况下可能会导致find变成O(n)
	- 高度规则：把更矮/更低rank的树作为subtree
	![[uptree3.png]]
	- 路径压缩：令每个元素都直接指向根
	![[uptree4.png]]
	分析：节点 x 的 `rank(x)` 是其高度的一个上界，如果 x≠parent(x)，那么有rank(parent(x))>rank(x)
	-  **引理 1（Lemma 1）：** 以 x 为根的树中，节点的数量**至少**为2^rank(x)
	- **引理 2（Lemma 2）：** 对于任意整数 k≥0，秩为 k 的节点个数**至多**为n / 2^k
	- **引理 3（Lemma 3）：** 秩 **大于等于** k 的节点个数至多为：n / 2^{k-1}
	- **引理 4（Lemma 4）：** 一个节点所能拥有的最大秩为：log⁡n
	• 一旦一个节点变为非根节点，它的秩将**永久固定**。
	![[analy.png]]
	![[analy2.png]]
	![[analy3.png]]
	![[analy4.png]]