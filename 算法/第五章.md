![[amor.png]]

问题：![[Amor2.png]]

聚合方法：直接计算 n 个操作的总成本，将平均成本作为每个操作的摊销成本。所有操作的摊销成本都相同。可能需要不同角度的计算方式
	在这个例子里，算一列的cost更低，每一列翻转次数是[n/2^i]。最后求得total的是O(n)，平均的cost是O(1)
![[agg.png]]

核算法：
![[accounting.png]]
	对于刚刚的例子，计0到1花销为2￥ 1到0花销为0￥，当从0到1的时候存1￥到银行账户，当从1到0时从账户中取钱支付。计数器中的每个 1，在银行账户中都有 1 美元为其预留，因此总是有足够的资金来支付该操作。**最终：**  每次递增操作只会产生一个从 0 变成 1 的翻转。  所以递增操作的摊销代价为 **2**。

势能法：在这种方法中，我们为每个数据结构关联一个**势能（potential energy）**。势能代表“造成破坏的潜力”。**摊销代价 = 实际代价 + 新势能 − 旧势能**   即：必须为数据结构势能的增加付出代价。如果某个操作的实际代价很大，但大幅降低了势能，那么它的摊销代价就会很低。如何找到合适的势能函数：**观察是什么让一个数据结构变得糟糕。**
![[potential.png]]
	在例题中，1越多，数据结构越差，所以定义势能函数等于数据结构中1的个数![[potential2.png]]
	![[potential3.png]]

问题2：![[算法/dytable.png]]
聚合方法：![[dytable2.png]]

核算法：比聚合方法的优势是每个操作都可以被分配一个**具体的**摊销成本。![[dytable3.png]]
![[dytable4.png]]
势能算法：
![[dytable5.png]]![[dytable6.png]]
如果问题变成占有率小于1/2则减半表大小，则：
![[dytable7.png]]
![[dytable8.png]]![[dytable9.png]]