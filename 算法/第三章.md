**快速排序：
1. **分解（Divide）**：将数组围绕一个主元 xxx 分成两个子数组，使得左边子数组中的元素满足 ≤ xxx，右边子数组中的元素满足 ≥ xxx。   
2. **征服（Conquer）**：递归地排序两个子数组。
3. **合并（Combine）**：很简单（因为排序是就地进行的）。
**关键：** 线性时间的划分过程（partitioning procedure）。
时间取决于split的方式：T(n)=T(in)+T((1-i)n)+cita(n) 0<i<1
最坏情况：当原序列已经排好正负序的时候![[Pasted image 20250613182553.png]]
如果坏情况和好情况交叉：
![[quicksort.png]]
我们怎样才能确保自己通常是幸运的？若以“中间”（第 n/2个）元素为中心进行划分，仍然会遇到糟糕的输入排列。应该以**随机元素**为中心进行划分。在实际中效果很好。
**随机快排：** 运行时间与输入的排列顺序无关；没有特定输入会导致最坏情况的行为；最坏情况仅由随机数生成器的输出决定
![[randquicksort.png]]
![[randquicksort2.png]]
![[randquicksort3.png]]![[randquicksort4.png]]
![[randquicksort5.png]]
**比较排序**：仅通过元素之间的比较来确定它们的相对顺序。例如：插入排序、归并排序、快速排序、堆排序等。比较排序在最坏情况下的最佳运行时间是 O(nlog⁡n)

**决策树**：输入的序列到决策树里做匹配，最终根据叶节点的序号来重排
![[dectree.png]]
**决策树**可以模拟任何**比较排序**算法的执行过程：
- 每个输入规模 n 对应一棵树。
- 每次算法比较两个元素时，将其视为一次分裂操作。
- 树中包含了所有可能的指令路径上的比较操作。
- 算法的运行时间 = 所走路径的长度。
- 最坏情况的运行时间 = 树的高度。
![[dectree2.png]]
	推论：归并排序是一种渐进最优的比较排序算法。

从n个元素中找出第i小的元素：
- 正常算法：排序并找到第i个元素，最差运行时间O(nlgn)
- 随机分治算法：partition的时候需要使p-r的元素全部≤A[r]
	![[算法/findi.png]]
	- 复杂度分析：
	![[findi2.png]]
	![[findi3.png]]
	![[findi4.png]]
	![[findi5.png]]
	![[findi6.png]]
	- **随机顺序统计选择的总结**：运行速度快，期望线性时间，在实践中是非常优秀的算法。但最坏情况**非常**糟糕：O(n^2)。
- 在最差情况下也能线性时间的算法：
	![[findibetter.png]]
	则最终至少有3[n/10]的元素是小于等于x的且有至少3[n/10]的元素是大于等于x。对于n≥50，有3[n/10]≥n/4，则第四步=T(3n/4)
	![[findibetter2.png]]
	![[findibetter3.png]]

数据流模型：
![[stream.png]]正如我们在 Abrahamson-Kosaraju 算法中所看到的，  一个**频繁元素（frequent element**)是指出现次数达到 m/c的元素。**齐普夫定律（Zipf law）：** 典型的频率分布高度偏斜：只有少数元素非常频繁。  
比如，前 10% 的元素占据了总出现次数的 90%.我们关注的是找出最重（heaviest）的那些元素。
- 简单算法：为每一个token开一个计数器，但需要用n个计数器，实际上数量不够
- Misra-Gries算法，用空间O(c log m)，n是token种类，m是token个数，c是最多可用计数器个数
	![[mistra.png]]
	![[mistra2.png]]
	左侧的证明：考虑每次计数器 j被减一的时候，另外有 c 个计数器也同时被减一。  这意味着在每次这样的减一操作中，都会遇到 c 次除 j 以外的其他键。所以不会有比m/c更多次的减一操作