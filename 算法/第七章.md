最优解问题：有很多可行解，但要找到一个使得要求式最大或者最小的解
贪心算法：找当前时刻的最优解。希望它是全局最优解，但有时未必是。但更好编程
区间调度问题：![[算法/is.png]]
贪心方法：把工作按一定的规律排序，按顺序挑选与前一个工作compatible的工作
- 最早开始时间
- 最短工作时间
- 最少冲突（最少与该工作冲突的工作数）
- 最早结束时间：此时贪心算法是全局最优的。 O(nlgn)
	- 证明：![[is 1.png]]
		![[is2.png]]
区间调度变式（区间分割）：
![[isb.png]]   - 最早开始时间：是全局最优的 O(nlgn)
![[isb2.png]]
![[isb3.png]]
	证明它是最优的：寻找一个简单的“结构性”下界，用以说明所有可能的解至少必须达到某个值。然后证明：所考虑的算法总是能够达到这个下界。
		**定义**：一组开放区间的“深度”是指在任何给定时间内包含该时间的最大区间数。
		**关键观察**：所需教室数量 ≥ 区间深度。
		![[isb4.png]]
- 最短工作时间
- 最早结束时间

区间调度变式（每个Job有一个ddl，需要调度满足最小的延期时间和）：
- 最短工作时间：完全不管ddl
	![[isb5.png]]
- 最早ddl时间：完全不管工作时长。是全局最优的
	证明贪心的方法：![[isb7.png]]
	探索发现：存在**最优最小延迟时间**的方法**不含空闲时间**，而贪心算法中也没有空闲时间
	![[isb8.png]]
	![[isb9.png]]
	![[isb10.png]]
- 按ddl时间-工作时间升序：
	![[isb6.png]]

数据压缩-哈夫曼编码：定长的编码比较浪费空间，变长的编码可以根据token出现的频率来定制长度，节省20%-90%的空间
- 要求必须是前缀码：
	![[huffman.png]]
- 最优的编码一定是一个全二叉树，即每个内部节点有两个子节点（上图的右侧），有C个叶节点和C-1个内部节点
- 最终的B(T)=f(c)*d(c)的和  f代表频率，d代表在树上的深度
- 构建最优前缀码的方法：如果 pi>pj​，那么 li≤lj（概率大的符号编码要短）。**两个最长的码字长度应相等**。**这两个最长的码字仅在最后一位不同**。Take the two least likely symbols, merge them to get a size n – 1 problem. {p1,…,pn–1, pn}  → {p1,…, pn–2,pn–1+pn}
	![[huffman2.png]]
- 是一个二叉最小堆，高度是lgn，次数是n-1 时间复杂度是O(nlgn)

*分数背包问题*：O(nlgn)
![[fkp.png]]
![[fkp2.png]]
证明贪心算法是全局最优：
![[fkp3.png]]