给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和一个整数 `k` 。每一次操作中，你可以选择一个数并将它乘 `2` 。

你最多可以进行 `k` 次操作，请你返回 `nums[0] | nums[1] | ... | nums[n - 1]` 的最大值。

`a | b` 表示两个整数 `a` 和 `b` 的 **按位或** 运算。

**示例 1：**

	输入：nums = [12,9], k = 1
	输出：30
	解释：如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。

**示例 2：**

	输入：nums = [8,1,2], k = 2
	输出：35
	解释：如果我们对下标 0 处的元素进行操作，得到新数组 [32,1,2] 。此时得到最优答案为 32|1|2 = 35 。

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= 15`
## 想法

注意到乘2其实就是前移1位，要让最终值最大，应该要在位数最多的数中选一个一直前移

但是在所有位数最多的数中，具体移动哪个并不确定，还是要逐个实验过去

本身找位数最多的数时就需要遍历一遍，还需要记录其位置信息
计算的时候由于需要逐位取或，又要再遍历一遍，非常麻烦，令人很不想写

如果能做到在遍历的过程中，保留一部分或计算的结果，继承到下一次计算（因为连续遍历过程中每次只变化两个数），那么舍去找位数最多的遍历也是可以接受的，并且不需要自己转换二进制位数。

那么整个计算应该由变化数前或结果 | 变化数 | 变化数后或结果 的形式构成，暂且称为1，2，3部分

2部分需要遍历过程中实时运算；而1，3部分都可以事先按照顺序不停或得到

	def maximumOr(self, nums: List[int], k: int) -> int:

        n = len(nums)

        suf = [0]*(n+1)

        pre = [0]*(n+1)

        for i in range(n):

            pre[i+1] = nums[i] | pre[i]

            suf[n-i-2] = suf[n-i-1] | nums[n-i-1]

        ans = 0

        for i in range(n):

            ans = max(ans, pre[i] | (nums[i] << k) | suf[i])

        return ans

记录一个sb行径：因为写了

	suf=pre=[0]*(n+1)

前面一直没通过，头脑风暴半天后感觉是这句的问题，发现还真是，改掉就对了