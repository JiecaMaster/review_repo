给你一个字符串 `s` ，**下标从 0 开始** ，且长度为偶数 `n` 。字符串 **恰好** 由 `n / 2` 个开括号 `'['` 和 `n / 2` 个闭括号 `']'` 组成。

只有能满足下述所有条件的字符串才能称为 **平衡字符串** ：

- 字符串是一个空字符串，或者
- 字符串可以记作 `AB` ，其中 `A` 和 `B` 都是 **平衡字符串** ，或者
- 字符串可以写成 `[C]` ，其中 `C` 是一个 **平衡字符串** 。

你可以交换 **任意** 两个下标所对应的括号 **任意** 次数。

返回使 `s` 变成 **平衡字符串** 所需要的 **最小** 交换次数。

**示例 1：**

	输入：s = "][]["
	输出：1
	解释：交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串
	最终字符串变成 "[[]]" 。

**示例 2：**

	输入：s = "]]][[["
	输出：2
	解释：执行下述操作可以使字符串变成平衡字符串：
	- 交换下标 0 和下标 4 对应的括号，s = "[]][][" 。
	- 交换下标 1 和下标 5 对应的括号，s = "[[][]]" 。
	最终字符串变成 "[[][]]" 。

**示例 3：**

	输入：s = "[]"
	输出：0
	解释：这个字符串已经是平衡字符串。

**提示：**

- `n == s.length`
- `2 <= n <= 106`
- `n` 为偶数
- `s[i]` 为`'['` 或 `']'`
- 开括号 `'['` 的数目为 `n / 2` ，闭括号 `']'` 的数目也是 `n / 2`

## 想法

对于平衡字符串，其本质是在“\[ \]”的基础上重复或者在外侧添加括号对
即一切在正常语法中合法的括号组都应该是平衡字符串

对于合法的括号组，左括号在前，右括号在后，可以使用栈的思路，左括号入栈，出现右括号时即出栈，如果栈空时出现右括号则认为不合法

由于此题并不关心括号具体的包含逻辑，仅关心合法与否，所以可以仅关心空栈时是否有右括号出现：可以采用一个计数进行判断，左括号+1，右括号-1，当整体计数小于0时即不合法

对于此题中的交换操作，设交换了第i位的右括号与第j位的左括号，则对于第i位到第j位之前的计数，其值都应该+2，因此最佳操作应该是先交换最小的i位右括号和最大的j位左括号

维护数组左括号，右括号，截止计数

	left = []
	right = []
	num = []
	add = 0
	ans = 0
	#设置初始的数组
	for i in range(len(s)):
		if s[i] == "[":
			left.append(i)
			add+=1
			num.append(add)
		else:
			right.append(i)
			add-=1
			num.append(add)
	#遍历是否有计数<0，如果有，执行一次交换操作
	for i in range(len(num)):
		if num[i]<0:
			for j in range(right[0],left[-1])
				num[j] += 2
			left = left[1:]
			right = right[:-2]
			ans+=1
	return ans

此版本发现超时，考虑进一步优化的空间。根据题目意思，最终总是能够变为平衡字符串，考虑最小的计数需要经过几次+2可以大于0

	min = 0
	 for i in range(len(num)):
		 if num[i] < min:
			  min = num[i]
	return (-min)//2+(-min)%2
那么left和right也不需要被维护了，可以去掉

	num = []
	add = 0
	#设置初始的数组
	for i in range(len(s)):
		if s[i] == "[":
			add+=1
			num.append(add)
		else:
			add-=1
			num.append(add)
	min = 0
	 for i in range(len(num)):
		 if num[i] < min:
			  min = num[i]
	return (-min)//2+(-min)%2
