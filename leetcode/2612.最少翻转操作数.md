给你一个整数 `n` 和一个在范围 `[0, n - 1]` 以内的整数 `p` ，它们表示一个长度为 `n` 且下标从 **0** 开始的数组 `arr` ，数组中除了下标为 `p` 处是 `1` 以外，其他所有数都是 `0` 。

同时给你一个整数数组 `banned` ，它包含数组中的一些位置。`banned` 中第 **i** 个位置表示 `arr[banned[i]] = 0` ，题目保证 `banned[i] != p` 。

你可以对 `arr` 进行 **若干次** 操作。一次操作中，你选择大小为 `k` 的一个 **子数组** ，并将它 **翻转** 。在任何一次翻转操作后，你都需要确保 `arr` 中唯一的 `1` 不会到达任何 `banned` 中的位置。换句话说，`arr[banned[i]]` 始终 **保持** `0` 。

请你返回一个数组 `ans` ，对于 `[0, n - 1]` 之间的任意下标 `i` ，`ans[i]` 是将 `1` 放到位置 `i` 处的 **最少** 翻转操作次数，如果无法放到位置 `i` 处，此数为 `-1` 。

- **子数组** 指的是一个数组里一段连续 **非空** 的元素序列。
- 对于所有的 `i` ，`ans[i]` 相互之间独立计算。
- 将一个数组中的元素 **翻转** 指的是将数组中的值变成 **相反顺序** 。

**示例 1：**

	输入：n = 4, p = 0, banned = [1,2], k = 4
	输出：[0,-1,-1,1]
	解释：k = 4，所以只有一种可行的翻转操作，就是将整个数组翻转。一开始 1 在位置 0 处，所以将它翻转到位置 0 处需要的操作数为 0 。
	我们不能将 1 翻转到 banned 中的位置，所以位置 1 和 2 处的答案都是 -1 。
	通过一次翻转操作，可以将 1 放到位置 3 处，所以位置 3 的答案是 1 。

**示例 2：**

	输入：n = 5, p = 0, banned = [2,4], k = 3
	输出：[0,-1,-1,-1,-1]
	解释：这个例子中 1 一开始在位置 0 处，所以此下标的答案为 0 。
	翻转的子数组长度为 k = 3 ，1 此时在位置 0 处，所以我们可以翻转子数组 [0, 2]，但翻转后的下标 2 在 banned 中，所以不能执行此操作。
	由于 1 没法离开位置 0 ，所以其他位置的答案都是 -1 。

## 想法

翻转操作：

本质上是对1进行移动

	假如k%2=1 ，那么可以移动的步长是2，4，6……k-1
	假如k%2=0，那么可以移动的步长是1，3，5……k-1

同时需要考虑两侧的情况，当数离边缘不足k时，可移动的步长会变化

	以k=7为例
	对于位置0，仅能翻转到6处
	对于位置1，仅能翻转到5或7处
	对于位置2，翻转到4或6或8
	对于位置3，翻转到5或7或9…
总结：对于k//2-1之前的位置有影响，对于-1到-(k//2-1)的位置有影响

	以k=6为例
	位置0，翻转到5处
	位置1，翻转到4或6
	位置2，翻转到3或5或7……
总结：对于k//2-1之前的位置有影响，对于-1到-(k//2-1)的位置有影响

题解中对于这一部分的描述为：

	首先考虑位置 i 可以转移到的位置。对于子数组 [L,R] 中的任意下标 i，翻转后的下标为 L+R−i。当子数组向左或向右滑动时，L 和 R 同时增加或减少 1，那么翻转后的下标就增加或减少 2。也就是说，奇偶数下标之间的转移是分别连续的。比如，对于下标 i 来说，其经过翻转可达的位置只有 k−i−1,k−i+1,k−i+3,...,i+k−1 等。

	接着考虑翻转的范围，容易发现其受数组边界的约束。如果不考虑数组的起始和结束范围，i 经过一次翻转的范围是 [i−k+1,i+k−1]。当子数组在最左边时，L=0,R=k−1，i 翻转后是 0+(k−1)−i=k−i−1。当子数组在最右边时，L=n−k,R=n−1，i 翻转后是 (n−k)+(n−1)−i=2n−k−i−1。综上，i 经过 1 次翻转后的范围是：
	[max(i−k+1,k−i−1),min(i+k−1,2n−k−i−1)]

题目中另一个比较难解的点是如何避免重复查询，即当发现一个节点可达后，就将其记录为可达，而不是让不同的节点重复达到此点，官方题解中给出了两个方案：
1.平衡树 2.并查集

然而我早就忘记掉了这些都是什么,所以参考[[平衡二叉树]]和[[并查集]]两份文件的内容

平衡二叉树题解（没看出来跟平衡二叉树有啥关系）：

	def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:
    # 将禁止位置转换为集合，便于快速查找
    ban = set(banned)
    
    # 创建两个有序列表，分别存储奇数索引和偶数索引的可达位置
    sets = [SortedList(), SortedList()]
    for i in range(n):
        if i != p and i not in ban:
            sets[i % 2].add(i)
    
    # 初始化结果数组，-1表示无法到达
    ans = [-1] * n
    # 创建队列用于BFS搜索
    q = deque()
    q.append(p)
    # 起始位置的操作次数为0
    ans[p] = 0
    
    # BFS搜索
    while q:
        i = q.popleft()
        
        # 计算通过一次长度为k的反转可以到达的最小和最大位置
        mn = max(i - k + 1, k - i - 1)  # 最小可达位置
        mx = min(i + k - 1, 2 * n - k - i - 1)  # 最大可达位置
        
        # 确定目标集合（奇偶性）
        target_set = sets[mx % 2]
        to_remove = []
        
        # 遍历可达范围内的所有位置
        for val in target_set.irange(mn, mx):
            # 更新操作次数
            ans[val] = ans[i] + 1
            # 将新位置加入队列，继续BFS
            q.append(val)
            # 标记为待移除（已处理）
            to_remove.append(val)
        
        # 从集合中移除已处理的位置
        for val in to_remove:
            target_set.remove(val)
            
    return ans

并查集题解：

	# 创建两个并查集，分别对应移动至奇数位和偶数位
	# 因为反转后，移动的所有终点位置奇偶一致
	 fa = [[i for i in range(n + 2)] for _ in range(2)] 
	 # 处理禁止位置，将它们标记为不可用 
	 # 实现方式是将每个禁止位置与其后一个位置合并，表示跳过该位置 
	 for ban in banned: 
		 self.merge(fa[ban % 2], ban, ban + 2) 
	# 初始化答案数组
	ans = [-1] * n 
	# 初始化BFS队列 
	q = deque() 
	q.append(p) 
	ans[p] = 0 
	self.merge(fa[p % 2], p, p + 2) 
	# 开始BFS搜索 
	while q: 
		i = q.popleft() 
		# 当前处理的位置 
		# 计算从位置i通过一次长度为k的反转操作能够到达的最小和最大位置 
		# mn: 能达到的最小位置 
		# mx: 能达到的最大位置 
		mn = max(i - k + 1, k - i - 1) 
		mx = min(i + k - 1, n * 2 - k - i - 1) 
		# 从最小可能位置开始，寻找所有可达位置
		 j = mn 
		 while j <= mx: 
		 # 找到当前位置所在集合的代表元素（找下一个未访问的位置） 
			 fi = self.find(fa[mn % 2], j) 
			 # 如果找到的位置超出范围，结束搜索 
			 if fi > mx: 
				 break 
			 # 更新该位置的答案：当前位置操作次数+1 
			 ans[fi] = ans[i] + 1 
			 # 将新位置加入队列，继续BFS 
			 q.append(fi) 
			 # 标记该位置已访问 
			 self.merge(fa[mn % 2], fi, fi + 2) 
			 # 移动到下一个可能的位置 
			 j = fi + 2 
			 # 返回每个位置的最少操作次数 
	return ans 
		 
	def find(self, f, x): 
	""" 并查集的查找操作，带路径压缩 查找元素x所属的集合代表元素 """ 
	if f[x] == x: 
		return x 
	# 路径压缩：将x直接连接到代表元素，加速后续查找 
	f[x] = self.find(f, f[x]) 
	return f[x] 
	
	def merge(self, f, x, y): """ 并查集的合并操作 将元素x所在集合与元素y所在集合合并 """
	# 找到x和y的代表元素 
	fx = self.find(f, x) 
	fy = self.find(f, y) 
	# 将fx的父节点设为fy，完成合并 
	f[fx] = fy

