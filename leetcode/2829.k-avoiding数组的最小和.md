给你两个整数 `n` 和 `k` 。

对于一个由 **不同** 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 **k-avoiding** 数组。

返回长度为 `n` 的 **k-avoiding** 数组的可能的最小总和。

**示例 1：**

	输入：n = 5, k = 4
	输出：18
	解释：设若 k-avoiding 数组为 [1,2,4,5,6] ，其元素总和为 18 。
可以证明不存在总和小于 18 的 k-avoiding 数组。

**示例 2：**

	输入：n = 2, k = 6
	输出：3
	解释：可以构造数组 [1,2] ，其元素总和为 3 。
可以证明不存在总和小于 3 的 k-avoiding 数组。 

**提示：**

- `1 <= n, k <= 50`
## 想法

数组里两两求和不能等于k，那么就是对于较小的数i，集合里不能有k-i，但又要求集合需要大小为n，且要求集合元素和最小，所以缺漏的k-i需要从大于n的数里面去补。

首先考虑不需要补的情况：

1. 说到k是整数，由于集合元素不重复，所以最大的两数和为3，考虑k <= 2 的情况，不会有两数和等于k，所以直接取1,2,..n 求和即可

2. 或者，1,2,..n 的最大两数和为 2n-1 如果 k > 2n-1 则同样不会有两数和等于k， 也是取1,...n求和
   
然后考虑需要补的情况：

令 v = k // 2， 第一波可以从1,..,v，都不会出问题；然后从v+1,...,k-1 需要被删去， 所以一共需要补从 k 开始共 n-v 个数。把第一段和第二段分开求和即可。

对了，代码在/2会默认浮点数运算，所以一定要记得强制转化成int类型

    def minimumSum(self, n: int, k: int) -> int:
        if k <= 2 or k > 2*n - 1:
            ans = (1+n) * n / 2
            return int(ans)
        if k % 2 == 0:
            ans = (1+k/2) * k / 4 + (1.5 * k + n - 1) * (n - k/2)/2
        else:
            v = k // 2
            ans = (1+v) * v / 2 + (2*k +n - v - 1) * (n - v)/2
        return int(ans)